{"version":3,"file":"parse.modern.js","sources":["../src/parsers/date.js","../src/parsers/time.js","../src/parsers/index.js","../src/parsers/duration.js","../src/parsers/list.js","../src/index.js","../src/parse.js"],"sourcesContent":["'use strict'\n\nimport { parse, isMatch } from 'date-fns'\nimport { zonedTimeToUtc } from 'date-fns-tz/esm'\n\nconst loc = 'UTC'\nconst commonDateFormats = [\n  'yyyy-MM-dd',\n  'dd/MM/yyyy',\n  'dd/MM/yy',\n  'dd-MM-yyyy',\n  'dd-MM-yy',\n  'dd.MM.yyyy',\n  'dd.MM.yy'\n]\n\nexport default function parseDate(text) {\n  const match = commonDateFormats.map((format) => {\n    return isMatch(text, format)\n  })\n  if (match.indexOf(true) > -1) {\n    const date = zonedTimeToUtc(\n      parse(text, commonDateFormats[match.indexOf(true)], new Date()),\n      loc\n    ).toJSON()\n    return date.split('T')[0]\n  } else {\n    return null\n  }\n}\n","'use strict'\n\nimport { parse, isMatch } from 'date-fns'\nimport { zonedTimeToUtc, formatInTimeZone } from 'date-fns-tz/esm'\n\nconst loc = 'UTC'\nconst commonTimeFormats = ['HH:mm', 'HH.mm', 'hh:mm a', 'hh:mm A']\n\nexport default function parseTime(text) {\n  const match = commonTimeFormats.map((format) => {\n    return isMatch(text, format)\n  })\n  if (match.indexOf(true) > -1) {\n    const time = zonedTimeToUtc(\n      parse(text, commonTimeFormats[match.indexOf(true)], new Date()),\n      loc\n    )\n    return formatInTimeZone(time, loc, 'HH:mm')\n  } else {\n    return null\n  }\n}\n","'use strict'\n\nimport date from './date.js'\nimport time from './time.js'\nimport duration from './duration.js'\nimport list from './list.js'\n\nexport const parseDate = date\nexport const parseTime = time\nexport const parseDuration = duration\nexport const parseList = list\n","'use strict'\n\nexport default function parseDuration(text) {\n  let matched = false\n  const duration = {\n    hours: 0,\n    minutes: 0\n  }\n\n  const hoursAndMinutes = new RegExp(/([0-9]+)h([0-9]+)m/)\n  const hours = new RegExp(/([0-9]+)h/)\n\n  if (text.match(hoursAndMinutes)) {\n    matched = true\n    const [, h, m] = text.match(hoursAndMinutes)\n    duration.hours = parseInt(h)\n    duration.minutes = parseInt(m)\n  } else if (text.match(hours)) {\n    matched = true\n    const [, h] = text.match(hours)\n    duration.hours = parseInt(h)\n    duration.minutes = 0\n  }\n\n  if (matched) {\n    return duration\n  } else {\n    return null\n  }\n}\n","'use strict'\n\nexport default function parseList(list) {\n  return list.children\n    .map((item) => {\n      const listItem = {}\n      if (item.type === 'list') {\n        return parseList(list)\n      } else if (item.type === 'listItem') {\n        listItem.checked = item.checked\n        return item.children\n          .map((child) => {\n            if (child.type === 'paragraph') {\n              listItem.text = child.children\n                .map((c) => {\n                  if (c.type === 'link') {\n                    return c.children[0].value\n                  } else {\n                    return c.value\n                  }\n                })\n                .filter((x) => !!x)\n                .join('')\n              return listItem\n            }\n          })\n          .filter((x) => !!x)\n      }\n    })\n    .filter((x) => !!x)\n}\n","'use strict'\n\nimport github from '@actions/github'\nimport core from '@actions/core'\nimport parse from './parse.js'\n\nasync function run() {\n  core.info('Parsing issue body ...')\n\n  try {\n    const parsedContent = await parse(github.context.payload.issue.body)\n\n    if (parsedContent !== undefined) {\n      core.setOutput('data', parsedContent)\n    } else {\n      core.setFailed(`There was no valid payload found in the issue.`)\n    }\n  } catch (err) {\n    core.setFailed(err)\n  }\n}\n\nrun()\n","'use strict'\n\nimport { unified } from 'unified'\nimport remarkParse from 'remark-parse'\nimport remarkGfm from 'remark-gfm'\nimport slugify from '@sindresorhus/slugify'\nimport remarkStringify from 'remark-stringify'\nimport stripFinalNewline from 'strip-final-newline'\n\nimport {\n  parseDate,\n  parseTime,\n  parseDuration,\n  parseList\n} from './parsers/index.js'\n\nexport default async function parseMD(body) {\n  const tokens = await unified().use(remarkParse).use(remarkGfm).parse(body)\n  if (!tokens) {\n    return []\n  }\n\n  const structuredResponse = {}\n  let currentHeading = null\n  for (const token of tokens.children) {\n    const text = await unified()\n      .use(remarkGfm)\n      .use(remarkStringify)\n      .stringify(token)\n    const cleanText = stripFinalNewline(text)\n\n    // issue forms uses h3 as a heading\n    if (token.type === 'heading' && token.depth === 3) {\n      currentHeading = slugify(token.children[0].value)\n      structuredResponse[currentHeading] = {\n        title: token.children[0].value,\n        content: []\n      }\n    } else if (token.type === 'paragraph' && currentHeading) {\n      const obj = structuredResponse[currentHeading]\n\n      const date = parseDate(cleanText)\n      const time = parseTime(cleanText)\n      const duration = parseDuration(cleanText)\n\n      if (date) {\n        obj.date = date\n      }\n\n      if (time) {\n        obj.time = time\n      }\n\n      if (duration) {\n        obj.duration = duration\n      }\n\n      obj.content.push(cleanText)\n    } else if (token.type === 'list') {\n      const obj = structuredResponse[currentHeading]\n      obj.text = cleanText\n      obj.list = parseList(token).flat()\n    } else if (token.type === 'html') {\n      const obj = structuredResponse[currentHeading]\n      obj.content.push(token.html)\n    } else if (token.type === 'code') {\n      const obj = structuredResponse[currentHeading]\n      obj.lang = token.lang\n      obj.text = cleanText\n    } else if (token.type === 'heading' && token.depth > 3) {\n      const obj = structuredResponse[currentHeading]\n      obj.content.push(token.children[0].value)\n    } else {\n      console.log('unhandled token type')\n      console.log(token)\n    }\n  }\n\n  for (const key in structuredResponse) {\n    const token = structuredResponse[key]\n    const content = token.content.filter(Boolean)\n    if (content && content.length > 0) {\n      if (content.length === 1) {\n        token.text = content[0]\n      }\n      token.text = content.join('\\n\\n')\n    }\n    token.content = content\n  }\n\n  return structuredResponse\n}\n"],"names":["commonDateFormats","commonTimeFormats","parseDate","text","match","map","format","isMatch","indexOf","zonedTimeToUtc","parse","Date","toJSON","split","parseTime","time","formatInTimeZone","parseDuration","matched","duration","hours","minutes","hoursAndMinutes","RegExp","h","m","parseInt","parseList","list","children","item","listItem","type","checked","child","c","value","filter","x","join","async","core","info","parsedContent","body","tokens","unified","use","remarkParse","remarkGfm","structuredResponse","currentHeading","token","remarkStringify","stringify","cleanText","stripFinalNewline","depth","slugify","title","content","obj","date","push","flat","html","lang","console","log","key","Boolean","length","github","context","payload","issue","undefined","setOutput","setFailed","err","run"],"mappings":"iXAKA,MACMA,EAAoB,CACxB,aACA,aACA,WACA,aACA,WACA,aACA,YCPIC,EAAoB,CAAC,QAAS,QAAS,UAAW,WCC3CC,EFSE,SAAmBC,GAChC,MAAMC,EAAQJ,EAAkBK,IAAKC,GAC5BC,EAAQJ,EAAMG,IAEvB,OAAIF,EAAMI,SAAQ,IAAS,EACZC,EACXC,EAAMP,EAAMH,EAAkBI,EAAMI,SAAQ,IAAQ,IAAIG,MAjBlD,OAmBNC,SACUC,MAAM,KAAK,SEjBdC,EDAWA,SAAUX,GAChC,MAAMC,EAAQH,EAAkBI,IAAKC,GAC5BC,EAAQJ,EAAMG,IAEvB,GAAIF,EAAMI,SAAQ,IAAS,EAAG,CAC5B,MAAMO,EAAON,EACXC,EAAMP,EAAMF,EAAkBG,EAAMI,SAAQ,IAAQ,IAAIG,MATlD,OAYR,OAAOK,EAAiBD,EAZhB,MAY2B,SAEnC,OAAO,MCVEE,ECPE,SAAuBd,GACpC,IAAIe,GAAU,EACd,MAAMC,EAAW,CACfC,MAAO,EACPC,QAAS,GAGLC,EAAkB,IAAIC,OAAO,sBAC7BH,EAAQ,IAAIG,OAAO,aAEzB,GAAIpB,EAAKC,MAAMkB,GAAkB,CAC/BJ,GAAU,EACV,MAASM,CAAAA,EAAGC,GAAKtB,EAAKC,MAAMkB,GAC5BH,EAASC,MAAQM,SAASF,GAC1BL,EAASE,QAAUK,SAASD,QACnBtB,GAAAA,EAAKC,MAAMgB,GAAQ,CAC5BF,GAAU,EACV,OAASM,GAAKrB,EAAKC,MAAMgB,GACzBD,EAASC,MAAQM,SAASF,GAC1BL,EAASE,QAAU,EAGrB,OAAIH,EACKC,QDfEQ,EERE,SAASA,EAAUC,GAChC,OAAOA,EAAKC,SACTxB,IAAKyB,IACJ,MAAMC,EAAW,GACjB,MAAkB,SAAdD,EAAKE,KACAL,EAAUC,GACM,aAAdE,EAAKE,MACdD,EAASE,QAAUH,EAAKG,QACjBH,EAAKD,SACTxB,IAAK6B,IACJ,GAAmB,cAAfA,EAAMF,KAWR,OAVAD,EAAS5B,KAAO+B,EAAML,SACnBxB,IAAK8B,GACW,SAAXA,EAAEH,KACGG,EAAEN,SAAS,GAAGO,MAEdD,EAAEC,OAGZC,OAAQC,KAAQA,GAChBC,KAAK,IACDR,IAGVM,OAAQC,KAAQA,SAlBd,IAqBRD,OAAQC,KAAQA,KCvBrBE,iBACEC,EAAKC,KAAK,0BAEV,IACE,MAAMC,QCMKH,eAAuBI,GACpC,MAAMC,QAAeC,IAAUC,IAAIC,GAAaD,IAAIE,GAAWvC,MAAMkC,GACrE,IAAKC,EACH,MAAO,GAGT,MAAMK,EAAqB,GAC3B,IAAIC,EAAiB,KACrB,IAAK,MAAMC,KAASP,EAAOhB,SAAU,CACnC,MAAM1B,QAAa2C,IAChBC,IAAIE,GACJF,IAAIM,GACJC,UAAUF,GACPG,EAAYC,EAAkBrD,GAGpC,GAAmB,YAAfiD,EAAMpB,MAAsC,IAAhBoB,EAAMK,MACpCN,EAAiBO,EAAQN,EAAMvB,SAAS,GAAGO,OAC3Cc,EAAmBC,GAAkB,CACnCQ,MAAOP,EAAMvB,SAAS,GAAGO,MACzBwB,QAAS,SAEN,GAAmB,cAAfR,EAAMpB,MAAwBmB,EAAgB,CACvD,MAAMU,EAAMX,EAAmBC,GAEzBW,EAAO5D,EAAUqD,GACjBxC,EAAOD,EAAUyC,GACjBpC,EAAWF,EAAcsC,GAE3BO,IACFD,EAAIC,KAAOA,GAGT/C,IACF8C,EAAI9C,KAAOA,GAGTI,IACF0C,EAAI1C,SAAWA,GAGjB0C,EAAID,QAAQG,KAAKR,QACZ,GAAmB,SAAfH,EAAMpB,KAAiB,CAChC,MAAM6B,EAAMX,EAAmBC,GAC/BU,EAAI1D,KAAOoD,EACXM,EAAIjC,KAAOD,EAAUyB,GAAOY,YACvB,GAAmB,SAAfZ,EAAMpB,KACHkB,EAAmBC,GAC3BS,QAAQG,KAAKX,EAAMa,WAClB,GAAmB,SAAfb,EAAMpB,KAAiB,CAChC,MAAM6B,EAAMX,EAAmBC,GAC/BU,EAAIK,KAAOd,EAAMc,KACjBL,EAAI1D,KAAOoD,MACa,YAAfH,EAAMpB,MAAsBoB,EAAMK,MAAQ,EACvCP,EAAmBC,GAC3BS,QAAQG,KAAKX,EAAMvB,SAAS,GAAGO,QAEnC+B,QAAQC,IAAI,wBACZD,QAAQC,IAAIhB,IAIhB,IAAK,MAAMiB,KAAOnB,EAAoB,CACpC,MAAME,EAAQF,EAAmBmB,GAC3BT,EAAUR,EAAMQ,QAAQvB,OAAOiC,SACjCV,GAAWA,EAAQW,OAAS,IACP,IAAnBX,EAAQW,SACVnB,EAAMjD,KAAOyD,EAAQ,IAEvBR,EAAMjD,KAAOyD,EAAQrB,KAAK,SAE5Ba,EAAMQ,QAAUA,EAGlB,OAAOV,EDhFuBxC,CAAM8D,EAAOC,QAAQC,QAAQC,MAAM/B,WAEzCgC,IAAlBjC,EACFF,EAAKoC,UAAU,OAAQlC,GAEvBF,EAAKqC,UAAW,kDAElB,MAAOC,GACPtC,EAAKqC,UAAUC,IAInBC"}